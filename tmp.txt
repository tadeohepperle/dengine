

// struct VertexOutput{
//     @builtin(position) clip_position: vec4<f32>,
//     @location(0) color: vec4<f32>,
//     @location(1) uv: vec2<f32>,
// }

// struct PosAndUv{
//     pos: vec2<f32>,
//     uv: vec2<f32>,
// }

// fn pos_and_uv(vertex_index: u32, sprite: SpriteInstance) -> PosAndUv{
//     var out: PosAndUv;
//     let size = sprite.size;
//     let size_half = size / 2.0;
//     let u_uv = unit_uv_from_idx(vertex_index);
//     out.uv = ((vec2(1.0) - u_uv) * sprite.uv.xy) + (u_uv * sprite.uv.zw);

//     let rot = sprite.rotation;
//     let pos = ((vec2(u_uv.x, 1.0 -u_uv.y)) * size) - size_half;
//     let pos_rotated = vec2(
//         cos(rot)* pos.x - sin(rot)* pos.y,
//         sin(rot)* pos.x + cos(rot)* pos.y,     
//     );
//     out.pos = pos_rotated + sprite.pos;
//     return out;
// }

// // , sprite: SpriteInstance


// @vertex
// fn vs_standard(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
//     let pos_and_uv = pos_and_uv(vertex_index, sprite);
//     let camera_pos = vec2(0,0);
//     let camera_size = vec2(10,20);
//     let ndc: vec2 = -(pos_and_uv.pos - camera_pos) / camera_size;
//     var out: VertexOutput;
//     out.clip_position = vec4<f32>(ndc, 0.0, 1.0);
//     out.color = sprite.color;
//     out.uv = pos_and_uv.uv;
//     return out;
// }

// @fragment
// fn fs_standard(in: VertexOutput) -> @location(0) vec4<f32>  {
//     return in.color;
//     // let image_color = textureSample(t_diffuse, s_diffuse, in.uv);
//     // let col = image_color * in.color;
//     // let n_coord = in.clip_position.xy / in.clip_position.w / vec2(screen.width, screen.height);
//     // // let d = distance(vec2(0.5,0.5), n_coord);
//     // // let s = smoothstep(0.5,0.2,d);
//     // // return vec4(col.rgb * s, col.a);
//     // let light = textureSample(t_light, s_light, n_coord);
//     // return col * light;
// }

// @vertex
// fn vs_unlit(@builtin(vertex_index) vertex_index: u32, sprite: SpriteInstance) -> VertexOutput {
//     let pos_and_uv = pos_and_uv(vertex_index, sprite);
//     let world_position = vec4<f32>(pos_and_uv.pos, 0.0, 1.0);
//     var out: VertexOutput;
//     out.clip_position = camera.view_proj * world_position;
//     out.color = sprite.color;
//     out.uv = pos_and_uv.uv;
//     return out;
// }

// @fragment
// fn fs_unlit(in: VertexOutput) -> @location(0) vec4<f32>  {
//     let image_color = textureSample(t_diffuse, s_diffuse, in.uv);
//     return image_color * in.color;
// }

// struct ShadowVertexOutput{
//     @builtin(position) clip_position: vec4<f32>,
//     @location(1) uv_and_alpha: vec3<f32>,
// }

// @vertex
// fn vs_shadow(@builtin(vertex_index) vertex_index: u32, sprite: SpriteInstance) -> ShadowVertexOutput {
//     let sun_dir = sprite.color.xy;
//     let alpha = sprite.color.z * sprite.color.a; // global sprite shadow alpha * alpha of the original color of this sprite

//     let u_uv = unit_uv_from_idx(vertex_index);
//     let mod_uv = vec2(u_uv.x, 1.0 -u_uv.y);
//     let uv = ((vec2(1.0) - mod_uv) * sprite.uv.xy) + (mod_uv * sprite.uv.zw);

//     let half_size = sprite.size / 2.0;
//     let anchor_pos = vec2(sprite.pos.x, sprite.pos.y - half_size.y); // bottom center of original sprite
//     let rel_pos = vec2(u_uv.x* sprite.size.x - half_size.x, u_uv.y * sprite.size.y);
//     let t_mat = mat2x2f(
//         1.0, 0.0, 
//         sun_dir.x, sun_dir.y,
//     );

//     let pos = anchor_pos + t_mat * rel_pos;
//     let world_position = vec4<f32>(pos, 0.0, 1.0);

//     var out: ShadowVertexOutput;
//     out.clip_position = camera.view_proj * world_position;
//     out.uv_and_alpha = vec3<f32>(uv, alpha);
//     return out;
// }

// @fragment
// fn fs_shadow(in: ShadowVertexOutput) -> @location(0) vec4<f32>  {
//     let uv = in.uv_and_alpha.xy;
//     let alpha = in.uv_and_alpha.z;
//     let image_color = textureSample(t_diffuse, s_diffuse, uv);
//     // return vec4f(uv, 1.0,1.0);
//     return vec4<f32>(0.0, 0.0, 0.0, image_color.a * alpha);
// }


// @vertex
// fn vs_indicator(@builtin(vertex_index) vertex_index: u32, sprite: SpriteInstance) -> VertexOutputIndicator {
//     let size = sprite.size;
//     let size_half = size / 2.0;
//     let u_uv = unit_uv_from_idx(vertex_index);
//     let rot = sprite.rot;
//     let pos = ((vec2(u_uv.x, 1.0 -u_uv.y)) * size) - size_half;
//     let pos_rotated = vec2(
//         cos(rot)* pos.x - sin(rot)* pos.y,
//         sin(rot)* pos.x + cos(rot)* pos.y,     
//     );
//     let pos_w = pos_rotated + sprite.pos;
//     let world_position = vec4<f32>(pos_w, 0.0, 1.0);
//     var out: VertexOutputIndicator;
//     out.clip_position = camera.view_proj * world_position;
//     out.color = sprite.color;
//     out.unit_uv = u_uv;
//     out.uv_aabb = sprite.uv;    
//     out.pos = pos_w;
//     out.size = sprite.size;
//     return out;
// }

// struct VertexOutputIndicator{
//     @builtin(position) clip_position: vec4<f32>,
//     @location(0) color: vec4<f32>,
//     @location(1) unit_uv: vec2<f32>,
//     @location(2) uv_aabb: vec4<f32>,
//     @location(3) pos: vec2<f32>,
//     @location(4) size: vec2<f32>,  
// }

// @fragment
// fn fs_indicator(in: VertexOutputIndicator) -> @location(0) vec4<f32>  {
//     // let zoom: f32 = 100.0 + sin(time.total * in.uv.x) * 10.0;
//     let n = perlinNoise2(in.pos* 2.0 + time.total);
//     let u_uv = (in.unit_uv-0.5)*(1.0 + sin(time.total * 4.0)*0.04) + 0.5 + n * 0.05;
//     let uv = ((vec2(1.0) - u_uv) * in.uv_aabb.xy) + (u_uv * in.uv_aabb.zw);

//     let image_color = textureSample(t_diffuse, s_diffuse, uv); // 
//     let s = (time.total + in.pos.x + 100.0) * n /  10.0;
//     let modi = vec4(1.0 + sin(s)*0.2, 1.0 +cos(s)*0.2, 1.3, 1.0);

//     return image_color * modi + vec4(in.color.xyz, 0.0); // vec4(0.7, 0.7,0.2, 0.0); // + vec4(in.unit_uv, 1.0,0.0); // + vec4(0.5 + sin(time.total * 12.0)*0.2, 0.5, 0.0, 0.0);
// }

// // for fs: see alpha_sdf_fs in alpha_sdf.wgsl          
// fn unit_uv_from_idx(idx: i32) -> vec2<f32> {
//     return vec2<f32>(
//         f32(((idx << 1) & 2) >> 1),
//         f32((idx & 2) >> 1)
//     );
// }

// // MIT License. Â© Stefan Gustavson, Munrocket
// //
// fn permute4(x: vec4f) -> vec4f { return ((x * 34. + 1.) * x) % vec4f(289.); }
// fn fade2(t: vec2f) -> vec2f { return t * t * t * (t * (t * 6. - 15.) + 10.); }

// fn perlinNoise2(P: vec2f) -> f32 {
//     var Pi: vec4f = floor(P.xyxy) + vec4f(0., 0., 1., 1.);
//     let Pf = fract(P.xyxy) - vec4f(0., 0., 1., 1.);
//     Pi = Pi % vec4f(289.); // To avoid truncation effects in permutation
//     let ix = Pi.xzxz;
//     let iy = Pi.yyww;
//     let fx = Pf.xzxz;
//     let fy = Pf.yyww;
//     let i = permute4(permute4(ix) + iy);
//     var gx: vec4f = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...
//     let gy = abs(gx) - 0.5;
//     let tx = floor(gx + 0.5);
//     gx = gx - tx;
//     var g00: vec2f = vec2f(gx.x, gy.x);
//     var g10: vec2f = vec2f(gx.y, gy.y);
//     var g01: vec2f = vec2f(gx.z, gy.z);
//     var g11: vec2f = vec2f(gx.w, gy.w);
//     let norm = 1.79284291400159 - 0.85373472095314 *
//         vec4f(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
//     g00 = g00 * norm.x;
//     g01 = g01 * norm.y;
//     g10 = g10 * norm.z;
//     g11 = g11 * norm.w;
//     let n00 = dot(g00, vec2f(fx.x, fy.x));
//     let n10 = dot(g10, vec2f(fx.y, fy.y));
//     let n01 = dot(g01, vec2f(fx.z, fy.z));
//     let n11 = dot(g11, vec2f(fx.w, fy.w));
//     let fade_xy = fade2(Pf.xy);
//     let n_x = mix(vec2f(n00, n01), vec2f(n10, n11), vec2f(fade_xy.x));
//     let n_xy = mix(n_x.x, n_x.y, fade_xy.y);
//     return 2.3 * n_xy;
// }




// #import uniforms.wgsl
// @group(1) @binding(0)
// var t_diffuse: texture_2d<f32>;
// @group(1) @binding(1)
// var s_diffuse: sampler;


// struct Globals {
//     a_uniform: vec2<f32>,
//     another_uniform: vec2<f32>
// }
// @group(0) @binding(0)
// var<uniform> globals: Globals;




@vertex
fn vs_main(@builtin(vertex_index) in_vertex_index: u32, instance: SpriteInstance) -> @builtin(position) vec4<f32> {
	let x = f32(i32(in_vertex_index) - 1);
	let y = f32(i32(in_vertex_index & 1u) * 2 - 1);
	return vec4<f32>(x, y, 0.0, 1.0);
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
	return vec4<f32>(1.0, 0.0, 0.0, 1.0);
}